OSDAnnotations.FabricWrapper = class extends XOpatViewerSingleton {

    constructor(viewer) {
        super(viewer);

        let refTileImage = viewer.scalebar.getReferencedTiledImage() || viewer.world.getItemAt(0);
        this.overlay = viewer.fabricjsOverlay({
            scale: refTileImage.source.dimensions ?
                refTileImage.source.dimensions.x : refTileImage.source.Image.Size.Width,
            fireRightClick: true
        });
        this.overlay.resizecanvas(); //if plugin loaded at runtime, 'open' event not called
        // this._debugActiveObjectBinder();

        this.__selectionSnapshot = null;
        this.__snapshotIsModifierToggle = false;
        this._trackedDoppelGangers = {};
        this._dopperlGangerCount = 0;
        // todo move layers functionality?


        this._layers = {};					// all existing layers (id -> layer)
        this._layer = undefined;			// active layer (last selected)
        this._selectedLayers = new Set();   // all selected layers (ids)
        this._setListeners();

        /**
         * @type {OSDAnnotations}
         */
        this.module = OSDAnnotations.instance();
    }

    setMouseOSDInteractive(isOSDInteractive) {
        if (isOSDInteractive) {
            this.setOSDTracking(true);
            this.canvas.defaultCursor = "grab";
            this.canvas.hoverCursor = "pointer";
        } else {
            this.setOSDTracking(false);
            this.canvas.defaultCursor = "crosshair";
            this.canvas.hoverCursor = "pointer";
        }
    }

    /**
     * Returns additional properties to copy (beside all properties generated by fabricjs)
     * @private
     */
    _exportedPropertiesGlobal(all=true) {
        const props = new Set(
            all ? OSDAnnotations.AnnotationObjectFactory.copiedProperties :
                OSDAnnotations.AnnotationObjectFactory.necessaryProperties
        );
        for (let fid in this.module.objectFactories) {
            const factory = this.module.objectFactories[fid];
            const newProps = factory.exports();
            if (Array.isArray(newProps)) {
                for (let p of newProps) {
                    props.add(p);
                }
            }
        }
        return Array.from(props);
    }

    /**
     * Change the interactivity - enable or disable navigation in OpenSeadragon
     * does not fire events, does not update anything, meant to be called from AnnotationState
     * or internally.
     * @package-private
     * @param {boolean} tracking
     */
    setOSDTracking(tracking) {
        this.viewer.setMouseNavEnabled(tracking);
    }


    /**
     * Creates a copy of exported list of objects with necessary values only
     * @param {[]|{}} objectList array of annotations or object with 'objects' array (as comes from this.toObject())
     * @param {string} keeps additional properties to keep
     * @return {[]|{}} clone array with trimmed values or modified object where 'objects' prop refers to the trimmed data
     */
    trimExportJSON(objectList, ...keeps) {
        let array = objectList;
        if (!Array.isArray(array)) {
            array = objectList.objects;
        }
        const _this = this;
        array = array.map(x => {
            //we define factories for types as default implementations too
            const factory = _this.module.getAnnotationObjectFactory(x.factoryID || x.type);
            if (!factory) return undefined; //todo error? or skips?
            return factory.copyNecessaryProperties(x, keeps, true);
        });
        if (!Array.isArray(objectList)) {
            objectList.objects = array;
            return objectList;
        }
        return array;
    }

    /**
     * Export annotations and presets
     * @param {{}} options options
     * @param {string?} options.format a string that defines desired format ID as registered
     *   in OSDAnnotations.Convertor, default 'native'
     * @param {object?} options.bioformatsCroppingRect
     * @param {boolean?} options.serialize rather internally used, true to serialize the output, false to optimize
     *   encoding, ready for exportFinalize()
     * @param {boolean} withAnnotations
     * @param {boolean} withPresets
     * @return Promise(object) partially serialized data, ready to be finished with exportFinalize:
     *   objects: [(string|any)] serialized or un
     */
    async exportPartial(options={}, withAnnotations=true, withPresets=true) {
        if (!options?.format) options.format = "native";
        const result = await OSDAnnotations.Convertor.encodePartial(options, this, withAnnotations, withPresets);
        this.module.raiseEvent('export-partial', {
            owner: this,
            options: options,
            data: result
        });
        return result;
    }

    /**
     * Export annotations and presets
     * @param {object} data output of exportPartial(...) with a correct format!
     * @param {string?} format default 'native'
     */
    exportFinalize(data, format='native') {
        const result = OSDAnnotations.Convertor.encodeFinalize(format, data);
        this.module.raiseEvent('export', {
            owner: this,
            data: result
        });
        return result;
    }

    /**
     * Export annotations and presets
     * @param {{}} options options
     * @param {string?} options.format a string that defines desired format ID as registered in OSDAnnotations.Convertor,
     *	note that serialize option is ignored, as export() serializes always
     * @param {object?} options.bioformatsCroppingRect
     * @param {boolean} withAnnotations
     * @param {boolean} withPresets
     * @return Promise((string|object)) serialized data or object of serialized annotations and presets (if applicable)
     */
    async export(options={}, withAnnotations=true, withPresets=true) {
        if (!options?.format) options.format = "native";
        //prevent immediate serialization as we feed it to a merge immediately, -> we don't reuse exportPartial(..)
        options.serialize = false;
        let output = await OSDAnnotations.Convertor.encodePartial(options, this, withAnnotations, withPresets);
        this.module.raiseEvent('export-partial', {
            owner: this,
            options: options,
            data: output
        });
        output = OSDAnnotations.Convertor.encodeFinalize(options.format, output);
        this.module.raiseEvent('export', {
            owner: this,
            data: output
        });
        return output;
    }

    rerender() {
        this.canvas.requestRenderAll();
    }

    /**
     * Load annotation objects only, must keep the same structure that comes from 'toObject',
     * the load event should be preceded with preset load event
     * for loading presets, see this.module.presets.import(...)
     * @param {object} annotations objects to import, {objects:[object]} format
     * @param {boolean} clear true if existing objects should be removed, default false
     * @param inheritSession
     * @return Promise
     */
    async loadObjects(annotations, clear=false, inheritSession=true) {
        //todo allow for 'redo' history (once layers are introduced)
        if (!annotations.objects) throw "Annotations object must have 'objects' key with the annotation data.";
        if (!Array.isArray(annotations.objects)) throw "Annotation objects must be an array.";
        return this._loadObjects(annotations, clear, inheritSession);
    }

    /**
     * Import annotations and presets. Imported presets automatically remove unused presets
     *   (no change in meta or no object created with).
     * todo allow also objects import not only string
     * @param {string} data serialized data of the given format
     * 	- either object with 'presets' and/or 'objects' data content - arrays
     * 	- or a plain array, treated as objects
     * @param {{}} options options
     * @param {string?} options.format a string that defines desired format ID as registered in OSDAnnotations.Convertor
     * @param {object?} options.bioformatsCroppingRect
     * @param {boolean} options.inheritSession set current session ID for the annotation if missing, default true
     * @param {boolean} clear erase state upon import
     * @return Promise(boolean) true if something was imported
     */
    async import(data, options={}, clear=false) {
        //todo allow for 'redo' history (once layers are introduced)

        if (!options?.format) options.format = "native";

        let toImport;
        try {
            toImport = await OSDAnnotations.Convertor.decode(options, data, this);
        } catch (e) {
            const formats = OSDAnnotations.Convertor.formats;
            const triedFormat = options.format;
            console.log(`Failed to load annotations as ${options.format}: ${e}, attempt to parse some of the remaining supported formats:`, formats);

            for (let format of formats) {
                if (format === triedFormat) continue;
                try {
                    options.format = format;
                    toImport = await OSDAnnotations.Convertor.decode(options, data, this);
                    console.log("Successfully parsed as", format);
                    break;
                } catch (_e) {
                    //pass
                }
            }

            if (!toImport) {
                console.error("No supported format was able to parse provided annotations data!");
            }
        }

        let imported = false;
        let inheritSession = options.inheritSession === undefined || options.inheritSession;

        // the import should happen in two stages, one that prepares the data and one that
        // loads so that integrity is kept -> this is not probably a big issue since the only
        // 'parsing' is done within preset import and it fails safely with exception in case of error

        if (Array.isArray(toImport) && toImport.length > 0) {
            imported = true;
            //if no presets, maybe we are importing object array
            await this._loadObjects({objects: toImport}, clear, inheritSession);
        } else {
            if (Array.isArray(toImport.presets) && toImport.presets.length > 0) {
                imported = true;
                await this.module.presets.import(toImport.presets, clear);
            }
            if (Array.isArray(toImport.objects) && toImport.objects.length > 0) {
                imported = true;
                await this._loadObjects(toImport, clear, inheritSession);
            }
        }

        if (imported) {
            this.module.historyManager.refresh();
        }

        this.module.raiseEvent('import', {
            owner: this,
            options: options,
            clear: clear,
            data: imported ? toImport : null,
        });

        return imported;
    }


    /**
     * Export only annotation objects in a fabricjs manner (actually just forwards the export command)
     * for exporting presets, see this.module.presets.export(...)
     *
     * The idea behind fabric exporting is to use _exportedPropertiesGlobal to ensure all properties
     * we want are included. Fabric's toObject will include plethora of properties. To trim down these,
     * trimExportJSON() is used to keep only necessary properties.
     *
     * @param {boolean|string} withAllProps if boolean, true means export all props, false necessary ones,
     *   string counts as one of withProperties
     * @param {((object) => boolean)|string} filter callback function to filter objects (applied to fabric objects before export),
     *   string counts as one of withProperties
     * @param {string[]} withProperties list of extra properties to export
     * @return {object} exported canvas content in {objects:[object], version:string} format
     */
    toObject(withAllProps=true, filter=false, ...withProperties) {
        let props;
        if (typeof withAllProps === "boolean") {
            props = this._exportedPropertiesGlobal(withAllProps);
        } else if (typeof withAllProps === "string") {
            props = this._exportedPropertiesGlobal(true);
            props.push(withAllProps);
        }

        if (typeof filter === "string") {
            props.push(filter);
            filter = undefined;
        }

        props.push(...withProperties);
        props.push(...this.module._extraProps);
        props = Array.from(new Set(props));

        let objectsToExport = this.canvas.getObjects();
        if (filter && typeof filter === "function") {
            objectsToExport = objectsToExport.filter(filter);
        }

        const data = {
            version: this.canvas.version,
            objects: objectsToExport.map(obj => obj.toObject(props))
        };

        if (withAllProps === true) return data;
        return this.trimExportJSON(data);
    }

    /**
     * FabricJS context
     * @member OSDdAnAnnotations
     * @return {fabric.Canvas}
     */
    get canvas() {
        return this.overlay.fabric;
    }

    /**
     * Find annotation by its increment ID
     * @param id
     * @return {null|fabric.Object}
     */
    findObjectOnCanvasByIncrementId(id) {
        //todo fabric.js should have some way how to avoid linear iteration over all objects...
        let target = null;
        this.canvas.getObjects().some(o => {
            if (o.incrementId === id) {
                target = o;
                return true;
            }
            return false;
        });
        return target;
    }

    /**
     * Hide or show annotations
     * @param {boolean} on
     */
    enableAnnotations(on) {
        let objects = this.canvas.getObjects();

        if (on) {
            //set all objects as visible and unlock
            for (let i = 0; i < objects.length; i++) {
                objects[i].visible = true;

                objects[i].lockRotation = false;
                objects[i].lockScalingFlip = false;
                objects[i].lockScalingX = false;
                objects[i].lockScalingY = false;
                objects[i].lockUniScaling = false;
            }
            if (this.cachedTargetCanvasSelection) {
                const selection = this.cachedTargetCanvasSelection;
                if (selection.type === 'activeSelection') {
                    selection.getObjects().forEach(obj => {
                        this.selectAnnotation(obj, true);
                        this.updateSingleAnnotationVisuals(obj);
                    });
                } else {
                    this.selectAnnotation(selection, true);
                    this.updateSingleAnnotationVisuals(selection);
                }
            }
        } else {
            this.cachedTargetCanvasSelection = this.canvas.getActiveObject();
            for (let i = 0; i < objects.length; i++) {
                //set all objects as invisible and lock in position
                objects[i].visible = false;
                objects[i].lockMovementX = true;
                objects[i].lockMovementY = true;
                objects[i].lockRotation = true;
                objects[i].lockScalingFlip = true;
                objects[i].lockScalingX = true;
                objects[i].lockScalingY = true;
                objects[i].lockSkewingX = true;
                objects[i].lockSkewingY = true;
                objects[i].lockUniScaling = true;
            }
            this.clearAnnotationSelection(true);
        }
        this.canvas.requestRenderAll();
    }


    /************************ Layers *******************************/

    /**
     * Check annotation for layer, assign if not assigned
     * @param {fabric.Object} ofObject
     * @return {OSDAnnotations.Layer} layer it belongs to
     */
    checkLayer(ofObject) {
        if (ofObject.hasOwnProperty("layerID") && String(ofObject.layerID) && !this._layers.hasOwnProperty(ofObject.layerID)) {
            this._createLayer({id: ofObject.layerID, _objects: []});
        }
    }

    /**
     * Set current active layer
     * @param layer layer to set
     */
    setActiveLayer(layer) {
        if (typeof layer === 'number') layer = this._layers[layer];
        this._layer = this._layers[layer.id];
        this._layer.setActive(true);

        this.raiseEvent('active-layer-changed', {
            id: String(this._layer.id)
        });
    }

    /**
     * Unset the current active layer (keeps selection intact)
     * @param {boolean} silent do not emit event
     */
    unsetActiveLayer() {
        if (!this._layer) return;
        this._layer.setActive(false);
        this._layer = undefined;

        this.raiseEvent('active-layer-changed', {
            id: undefined
        });
    }

    /**
     * Select a layer (optionally append for multi-selection).
     * @param {OSDAnnotations.Layer|number} layer layer instance or id
     * @param {boolean} append true to keep existing selection and add this one
     * @param {boolean} silent do not emit event
     */
    selectLayer(layer, silent=false) {
        if (typeof layer === 'number') layer = this._layers[layer];
        if (!layer) return;

        if (!this._selectedLayers.has(layer.id)) {
            this._selectedLayers.add(layer.id);
            layer.setActive(true);

            if (!silent) this._emitLayerSelectionChanged(layer.id, true);
        }
    }

    /**
     * Deselect a specific layer (if it was active, active layer becomes last remaining or undefined)
     * @param {number} layerId
     * @param {boolean} silent
     */
    deselectLayer(layerId, silent=false) {
        layerId = String(layerId);
        if (!this._selectedLayers.has(layerId)) return;
        const layer = this._layers[layerId];
        this._selectedLayers.delete(layerId);
        if (layer) layer.setActive(false);

        if (this._layer && this._layer.id === layerId) {
            const last = Array.from(this._selectedLayers).at(-1);
            last ? this.setActiveLayer(Number(last)) : this.unsetActiveLayer();
        }
        if (!silent) this._emitLayerSelectionChanged(layerId, false);
    }

    /**
     * Clear all layer selection (no active layer afterwards)
     * @param {boolean} silent
     */
    clearLayerSelection(silent=false) {
        if (this._selectedLayers.size === 0) return;
        const ids = this.getSelectedLayerIds();

        this._selectedLayers.forEach(id => {
            const l = this._layers[id];
            if (l) l.setActive(false);
        });

        this._selectedLayers.clear();
        if (!silent) this._emitLayerSelectionChanged(ids, false);
    }

    /**
     * Get array of selected layer instances
     * @returns {OSDAnnotations.Layer[]}
     */
    getSelectedLayers() {
        return Array.from(this._selectedLayers).map(id => this._layers[id]).filter(Boolean);
    }

    /**
     * Get array of selected layer IDs
     * @returns {string[]}
     */
    getSelectedLayerIds() {
        return Array.from(this._selectedLayers);
    }

    /**
     * Emit selection change event
     * @private
     */
    _emitLayerSelectionChanged(layerIds, isSelected) {
        const ids = Array.isArray(layerIds)
            ? layerIds.map(String)
            : (layerIds !== undefined && layerIds !== null ? String(layerIds) : layerIds);

        this.raiseEvent('layer-selection-changed', {
            ids: ids,
            isSelected: isSelected
        });
    }

    /**
     * Get layer by id
     * @param {number|string} id
     * @return {OSDAnnotations.Layer | undefined}
     */
    getLayer(id=undefined) {
        if (id === undefined) {
            return undefined;
        }
        return this._layers[id];
    }

    /**
     * Get all layers
     * @returns {OSDAnnotations.Layer[]}
     */
    getAllLayers() {
        return this._layers ? Object.values(this._layers) : [];
    }

    _serializeLayer(layerId) {
        const layer = this.getLayer(layerId);
        if (!layer) return null;

        const data = layer.toObject();
        if (this.module.historyManager) {
            data._position = this.module.historyManager.getBoardIndex('layer', layerId);
        }
        return data;
    }

    /**
     * Create new layer
     * @event layer-added
     * @param {number|string} id optional
     * @return {OSDAnnotations.Layer} new layer
     */
    createLayer(id=Date.now()) {
        id = String(id);
        let layerData = {id: id, _objects: []};

        this.module.history.push(
            () => this._createLayer(layerData),
            () => {
                layerData = this._serializeLayer(id);
                this._deleteLayer(id);
            }
        );
    }

    /**
     * Delete layer
     * @param id layer id
     */
    deleteLayer(id) {
        const layerData = this._serializeLayer(id);

        this.module.history.push(
            () => this._deleteLayer(id),
            () => this._createLayer(layerData)
        );
    }

    /**
     * Iterate layers
     * @param {function} callback called on layer instances (descending order)
     */
    forEachLayerSorted(callback) {
        let order = Object.keys(this._layers);
        order.sort((x, y) => (this._layers[x].position ?? 0) - (this._layers[y].position ?? 0));
        //order.sort((x, y) => this._layers[x] - this._layers[y]);
        for (let id of order) {
            callback(this._layers[id]);
        }
    }

    /**
     * Sort annotations to reflect current order of layers
     */
    sortObjects() {
        let _this = this;
        this.canvas._objects.sort((x, y) => {
            if (!x.hasOwnProperty('layerID') || !y.hasOwnProperty('layerID')) return 0;
            return _this._layers[x.layerID].position - _this._layers[y.layerID].position;
        });
        this.canvas.requestRenderAll();
    }

    /**
     * Get the active layer
     * @returns {OSDAnnotations.Layer} active layer
     */
    getActiveLayer() {
        return this._layer;
    }

    /**
     * Add an annotation to a layer.
     * If layerID is missing, adds to the active layer; no-op if no active layer found.
     * @param {fabric.Object} annotation
     * @param {number} [index] insert position; appends by default
     * @returns {void}
     */
    addAnnotationToLayer(annotation, index = undefined) {

        if (!annotation.hasOwnProperty("layerID")) {
            let activeLayer = this.getActiveLayer();
            if (!activeLayer){
                annotation.layerID = undefined;
                return;
            }

            annotation.layerID = activeLayer.id;
            activeLayer.addObject(annotation, index);
            return;
        }

        let layer = this.getLayer(annotation.layerID);
        if (!layer) return;
        layer.addObject(annotation, index);
    }

    /**
     * Remove annotation from its layer
     * @param {*} annotation
     */
    removeAnnotationFromLayer(annotation) {
        const layer = this.getLayer(annotation.layerID);
        if (layer) layer.removeObject(annotation);
    }

    /**
     * Delete object without knowledge of its identity (fully-fledged annotation or helper one)
     * @param {fabric.Object} o
     * @param _raise @private
     * @return {boolean} true if object was deleted
     */
    deleteObject(o, _raise=true) {
        // this._deletedObject = o;
        if (this.isAnnotation(o)) return this._deleteAnnotation(o, _raise);
        return this.deleteHelperAnnotation(o);
    }

    /**
     * Focus object without highlighting the focus within the board
     * @param {object|fabric.Object} object
     * @param {number|undefined} incremendId set to object id if highligh should take place and
     * 	focus item is not an instance of fabric.Object
     */
    focusObjectOrArea(object, incremendId=undefined) {
        if (object.incrementId) {
            object = this.module.historyManager._getFocusBBox(object);
        }
        this.module.historyManager._focus(object, incremendId);
    }


    /**
     * Add annotation to the canvas without registering it with with available features (history, events...)
     * @param {fabric.Object} annotation
     */
    addHelperAnnotation(annotation) {
        annotation.excludeFromExport = true;
        this.canvas.add(annotation);
    }

    /**
     * Convert helper annotation to fully-fledged annotation
     * @param {fabric.Object} annotation helper annotation
     * @param _raise @private
     * @param _dangerousSkipHistory @private, do not touch!
     * @return {boolean} true if annotation was promoted
     */
    promoteHelperAnnotation(annotation, _raise=true, _dangerousSkipHistory=false) {
        if (_dangerousSkipHistory) {
            return this._promoteHelperAnnotation(annotation, _raise, _dangerousSkipHistory);
        }
        // skip event if skipping history - internal logics
        let cancelFlag = false;
        try {
            this.raiseEvent('annotation-before-create', {
                object: annotation,
                isCancelled: () => cancelFlag,
                setCancelled: (cancelled) => {cancelFlag = cancelled},
            });
        } catch (e) { console.error('Error in annotation-before-create event handler: ', e); }
        if (cancelFlag) return false;
        return this.module.history.push(
            () => this._promoteHelperAnnotation(annotation, _raise, _dangerousSkipHistory),
            () => this._deleteAnnotation(annotation, _raise)
        );
    }

    _deleteAnnotation (annotation, _raise = true){
        let cancelFlag = false;
        try {
            if (annotation) {
                this.raiseEvent('annotation-before-delete', {
                    object: annotation,
                    isCancelled: () => cancelFlag,
                    setCancelled: (cancelled) => {cancelFlag = cancelled},
                });
            }
        } catch (e) { console.error("Error in annotation-before-delete handler:", e); }
        if (cancelFlag) return false;

        // todo, fires event -> respect _raise flag?
        if (this.isAnnotationSelected(annotation)) this.deselectAnnotation(annotation, true);

        this.canvas.remove(annotation);
        this.removeAnnotationFromLayer(annotation);
        this.module.historyManager.removeAnnotationFromBoard(annotation);
        this.canvas.requestRenderAll();

        if (_raise) {
            this.raiseEvent('annotation-delete', {object: annotation});
        }
        return true;
    }

    _promoteHelperAnnotation(annotation, _raise = true, _dangerousSkipHistory = false) {
        // annotation.off('deselected');
        delete annotation.excludeFromExport;
        if (Array.isArray(annotation._objects)) {
            for (let child of annotation._objects) delete child.excludeFromExport;
        }
        annotation.sessionID = this.module.session;
        annotation.author = XOpatUser.instance().id;
        annotation.created = annotation.created || Date.now();
        annotation.id = annotation.id || crypto.randomUUID();
        annotation.internalID = annotation.internalID || this.module._generateInternalId();

        const layerIndex = annotation.hasOwnProperty("_position") && annotation.layerID ? annotation._position : undefined;
        const boardIndex = annotation.hasOwnProperty("_position") && !annotation.layerID ? annotation._position : undefined;

        this.updateSingleAnnotationVisuals(annotation);
        this.addAnnotationToLayer(annotation, layerIndex);

        if (!_dangerousSkipHistory) this.module.historyManager.addAnnotationToBoard(annotation, undefined, boardIndex);
        // this.clearAnnotationSelection(true);
        // this.selectAnnotation(annotation, true);

        if (_raise) this.raiseEvent('annotation-create', {object: annotation});
        this.canvas.requestRenderAll();
        return true;
    }

    _addAnnotation(annotation, _raise = true) {
        this.addHelperAnnotation(annotation);
        const promoted = this._promoteHelperAnnotation(annotation, _raise, false);
        if (!promoted) this.deleteHelperAnnotation(annotation);
        return promoted;
    }

    _replaceAnnotation(previous, next, updateUI) {
        let boardIndex = undefined;
        if (previous.layerID) {
            const layerIndex = this.getLayer(previous.layerID).getAnnotationIndex(previous);
            this.removeAnnotationFromLayer(previous);
            this.addAnnotationToLayer(next, layerIndex);
        } else {
            boardIndex = this.module.historyManager.getBoardIndex('annotation', previous.incrementId);
        }

        this.canvas.remove(previous);
        this.canvas.add(next);

        if (updateUI) {
            this.module.historyManager.addAnnotationToBoard(next, previous, boardIndex);

            // this.clearAnnotationSelection(true);
            // this.selectAnnotation(next, true);
            this.raiseEvent('annotation-replace', {previous, next});
        }

        this.canvas.requestRenderAll();
    }

    _createLayer(layerData) {
        const restoredLayer = new OSDAnnotations.Layer(this, layerData.id);

        for (let [key, value] of Object.entries(layerData)) {
            restoredLayer[key] = value;
        }

        this._layers[layerData.id] = restoredLayer;
        const boardIndex = restoredLayer.hasOwnProperty("_position") ? restoredLayer._position : undefined;
        this.module.historyManager.addLayerToBoard(restoredLayer, boardIndex);

        for (let obj of layerData._objects) {
            this._addAnnotation(obj, false);
        }

        this.raiseEvent('layer-added', {layer: restoredLayer});
    }

    _deleteLayer(layerId) {
        let layer = this.getLayer(layerId);
        if (!layer) return;

        const layerObjects = [...layer.getObjects()];
        for (let obj of layerObjects) {
            this._deleteAnnotation(obj, false);
        }

        this.module.historyManager.removeLayerFromBoard(layer);
        delete this._layers[layerId];
        this._selectedLayers.delete(layerId);

        this.raiseEvent('layer-removed', {layer: layer});
    }

    /**
     * Change annotation's `private` property
     * @param {fabric.Object} annotation Any annotation
     * @param {boolean} value New value
     */
    setAnnotationPrivate(annotation, value) {
        if (annotation.private === value) return;
        annotation.private = value;
        this.raiseEvent('annotation-set-private', {object: annotation});
    }

    /**
     * Add comment to annotation
     * @param {fabric.Object} annotation Any annotation
     * @param {AnnotationComment} comment Comment to add
     */
    addComment(annotation, comment) {
        if (!annotation.comments) annotation.comments = [];
        annotation.comments.push(comment);
        this.raiseEvent('annotation-add-comment', {object: annotation, comment});
    }

    /**
     * Delete comment from annotation
     * @param {fabric.Object} annotation Any annotation
     * @param {string} comment Comment ID to delete
     * @returns {boolean} Whether the comment to delete was found
     */
    deleteComment(annotation, commentId) {
        if (!annotation.comments) return false;
        const found = annotation.comments.findIndex(c => c.id === commentId);
        if (found === -1) return false;
        // annotation.comments.splice(found, 1);
        annotation.comments[found].removed = true;
        this.raiseEvent('annotation-delete-comment', {object: annotation, commentId});
        return true;
    }

    /**
     * Add annotation to the canvas. Annotation will have NEW identity
     * (unlike helper annotation which is meant for visual purposes only).
     * If you wish to update annotation (type / geometry) but keep identity,
     * you must use replaceAnnotation() instead!
     * @param {fabric.Object} annotation
     * @param _raise @private
     * @return {boolean} true if annotation was added
     */
    addAnnotation(annotation, _raise=true) {
        return this.module.history.push(
            () => this._addAnnotation(annotation, _raise),
            () => this._deleteAnnotation(annotation, _raise)
        );
    }

    /**
     * Change the annotation
     * @param annotation
     * @param presetID
     * @param _raise
     * @return {boolean} true if preset updated
     */
    changeAnnotationPreset(annotation, presetID, _raise=true) {
        let cancelFlag = false;
        try {
            if (annotation) this.module.raiseEvent('annotation-before-preset-change', {
                object: annotation,
                isCancelled: () => cancelFlag,
                setCancelled: (cancelled) => {cancelFlag = cancelled},
            });
        } catch (e) { console.error("Error in annotation-before-preset-change handler:", e); }
        if (cancelFlag) return false;

        let factory = annotation._factory();
        if (factory !== undefined) {
            const oldPresetID = annotation.presetID;
            const options = this.module.presets.getAnnotationOptionsFromInstance(this.module.presets.get(presetID));
            factory.configure(annotation, options);
            this.canvas.requestRenderAll();
            if (_raise) this.module.raiseEvent('annotation-preset-change', {object: annotation, presetID: presetID, oldPresetID: oldPresetID});
            return true;
        }
        return false;
    }

    /**
     * Delete helper annotation, should not be used on full identity
     * annotation.
     * @param {fabric.Object} annotation helper annotation
     * @return {boolean} true if annotation was deleted
     */
    deleteHelperAnnotation(annotation) {
        this.canvas.remove(annotation);
        return true;
    }

    /**
     * Delete annotation
     * @param {fabric.Object} annotation
     * @param _raise @private
     * @return {boolean} true if annotation was deleted
     */
    deleteAnnotation(annotation, _raise=true) {
        this.module.history.push(
            () => this._deleteAnnotation(annotation, _raise),
            () => this._addAnnotation(annotation, _raise),
        );
    }

    /**
     * Get annotation description from a preset, overriden by own object meta if present
     * @param {fabric.Object} annotation annotation to describe
     * @param {string} desiredKey metadata key to read and return
     * @param {boolean} defaultIfUnknown if false, empty string is returned in case no property was found
     * @param {boolean} withCoordinates if true, includes coordinates in the default name
     * @return {string|*} annotation description
     */
    getAnnotationDescription(annotation, desiredKey="category", defaultIfUnknown=true, withCoordinates=true) {
        let preset = this.module.presets.get(annotation.presetID);
        if (preset) {
            for (let key in preset.meta) {
                let objmeta = annotation.meta || {}, overridingValue = objmeta[key];
                let metaElement = preset.meta[key];
                if (key === desiredKey) {
                    return overridingValue || metaElement.value ||
                        (defaultIfUnknown ? this.getDefaultAnnotationName(annotation, withCoordinates) : "");
                }
            }
        }
        return defaultIfUnknown ? this.getDefaultAnnotationName(annotation, withCoordinates) : "";
    }

    /**
     * Get annotation color as set by attached preset
     * @param {fabric.Object} annotation
     * @return {string} css color
     */
    getAnnotationColor(annotation) {
        let preset = this.module.presets.get(annotation.presetID);
        if (preset) {
            return preset.color;
        }
        return 'black';
    }

    /**
     * Get default annotation name
     * @param {fabric.Object} annotation
     * @param {boolean} [withCoordinates=true]
     * @return {string} annotation name created by factory
     */
    getDefaultAnnotationName(annotation, withCoordinates=true) {
        let factory = annotation._factory();
        if (factory !== undefined) {
            return withCoordinates ? factory.getDescription(annotation) : factory.title();
        }
        return "Unknown annotation.";
    }

    /**
     * Replace annotation with different one. This must not be done by manual removal and creation of a new instance.
     * Previous annotation must be already full annotation (promoted). This method also supports **temporal** replacement
     * of annotation by a doppelganger annotation. Doppelganger annotation is the same (structurally) as helper annotation,
     * but user expects it to BEHAVE like full annotation (=interactive). Helper annotation is added by addHelperAnnotation,
     * doppelganger is added by replaceAnnotation(.., dp, false), and must be removed by replaceAnnotation(dp, .., false) later on.
     * @param {fabric.Object} previous
     * @param {fabric.Object} next
     * @param {boolean} isDoppelganger
     * Example:
     *  - user selects annotation x and starts modification procedure: replaceAnnotation(x, y, false)
     *  - user drags mouse, the mouse events result in modification of the new HELPER annotation y that shows
     *  how user action changes the shape of the original object
     *  - user releases the mouse: system MUST call replaceAnnotation(y, x, false) that returns the previous
     *  state and optionally sets the final result by replaceAnnotation(x, y).
     *
     *  It is possible to also perform full exchange circle:
     *  replaceAnnotation(x, y, false)  replaceAnnotation(y, z, false) replaceAnnotation(z, x, false)
     *  and furthermore use z annotation to e.g. add it back to the canvas.
     * @return {boolean} true if annotation replacemed succeeded
     */
    replaceAnnotation(previous, next, isDoppelganger=false) {
        // We have to skip history since we will add these to history anyway, avoid duplicate entries

        let cancelFlag = false;
        if (!isDoppelganger) {
            try {
                if (previous) this.raiseEvent('annotation-before-replace', {
                    object: previous,
                    isCancelled: () => cancelFlag,
                    setCancelled: (cancelled) => {cancelFlag = cancelled},
                });
            } catch(e) { console.error('Error in annotation-before-replace event handler: ', e); }
        } else {
            try {
                if (previous) this.raiseEvent('annotation-before-replace-doppelganger', {
                    object: previous,
                    isCancelled: () => cancelFlag,
                    setCancelled: (cancelled) => {cancelFlag = cancelled},
                });
            } catch (e) { console.error('Error in annotation-before-replace-doppelganger event handler: ', e); }
        }
        if (cancelFlag) return false;

        if (isDoppelganger) {
            // Uses instance ID to track helper annotations on canvas
            const prevIsBeingReplaced = !!previous.internalID;
            const nextIsBeingReplaced = !!next.internalID;
            if (prevIsBeingReplaced && nextIsBeingReplaced) {
                // step backward, we come full circle (both have record of internalID)
                if (!this.isAnnotation(next)) {
                    console.error("[replaceAnnotation] next object must be full annotation when returning to the original state!", previous, next);
                    this.canvas.remove(previous);
                    return;
                }
                this._trackDoppelganger(next.internalID, previous, next,false);
                delete previous.internalID;
            } else if (prevIsBeingReplaced) {
                // step forward
                this._trackDoppelganger(previous.internalID, previous, next, true);
                next.internalID = previous.internalID;
            } else if (nextIsBeingReplaced) {
                // bad call, previous object must be on a canvas
                console.error("[replaceAnnotation] next object is on a canvas, but previous object not!", previous, next);
            } else {
                // bad call, no object on the canvas
                console.error("[replaceAnnotation] no full annotation object with temporary swap!", previous, next);
            }

            this._replaceAnnotation(previous, next, false);
            this.raiseEvent('annotation-replace-doppelganger', {previous, next});
            return true;
        }

        if (!this.isAnnotation(previous)) {
            // Try to recover
            console.warn("[replaceAnnotation] annotation is a helper object!", previous);
            this._promoteHelperAnnotation(previous, false, true);
        }

        // !! keep reference of entity identity the same !!
        next.internalID = previous.internalID;
        if (!this.isAnnotation(next)) {
            this._promoteHelperAnnotation(next, false, true);
        }

        return this.module.history.push(
            () => this._replaceAnnotation(previous, next, true),
            () => this._replaceAnnotation(next, previous, true)
        );
    }

    /**
     * Track doppelganger existence to ensure consistency of canvas
     * @param id
     * @param original
     * @param doppelganger
     * @param toAdd
     * @private
     */
    _trackDoppelganger(id, original, doppelganger, toAdd) {
        if (toAdd) {
            const existing = this._trackedDoppelGangers[id];
            if (existing === original) {
                this._dopperlGangerCount--;
            } else if (existing) {
                console.error("Doppelganger annotation attempt to overwrite existing doppelganger!", id, original, doppelganger);
                // try being consistent
                this.canvas.remove(existing);
                this._dopperlGangerCount--;
            }

            doppelganger._isDoppelganger = true;
            this._trackedDoppelGangers[id] = doppelganger;
            this._dopperlGangerCount++;
        } else {
            if (this._trackedDoppelGangers[id]) {
                delete this._trackedDoppelGangers[id];
                this._dopperlGangerCount--;
            } else {
                console.error("Doppelganger annotation not consistently tracked!", id, original, doppelganger);
            }
        }
    }

    _doppelgangerClear() {
        if (this._dopperlGangerCount > 0) {
            console.warn("[setMode] doppelganger found while switching modes: this is a bug. Removing...", this._trackedDoppelGangers);
            for (let dId in this._trackedDoppelGangers) {
                this.canvas.remove(this._trackedDoppelGangers[dId]);
            }
            this._dopperlGangerCount = 0;
            this._trackedDoppelGangers = {};
        }
    }

    /**
     * Check whether object is full annotation (not a helper or doppelganger)
     * @param {fabric.Object} o
     * @return {boolean}
     */
    isAnnotation(o) {
        return o.hasOwnProperty("incrementId") && o.hasOwnProperty("sessionID");
    }

    /**
     * Get array of selected annotation IDs (incrementId as strings)
     * @returns {string[]}
     */
    getSelectedAnnotationIds() {
        return this.getSelectedAnnotations()
            .map(obj => String(obj.incrementId))
            .filter(Boolean);
    }

    /**
     * Get array of selected annotation objects
     * @returns {fabric.Object[]}
     */
    getSelectedAnnotations() {
        const activeObject = this.canvas.getActiveObject();
        if (!activeObject) return [];

        return activeObject.type === 'activeSelection'
            ? activeObject._objects
            : [activeObject];
    }

    /**
     * Select an annotation by object or incrementId; supports multi-select.
     * @param {fabric.Object|number|string} annotation
     * @param {boolean} [fromCanvas=false] if the selection event originates on canvas, set true
     * @returns {void}
     */
    selectAnnotation(annotation, fromCanvas=false) {
        //todo fix this method
        if (annotation === null || annotation === undefined) return;
        const obj = typeof annotation === 'object' ?
            annotation : this.findObjectOnCanvasByIncrementId(Number(annotation));

        if (!obj) return;
        const canvas = this.canvas;
        const baseIds = this.__snapshotIsModifierToggle ? (this.__selectionSnapshot?.map(x => x.incrementId) || []) : this.getSelectionSnapshot();
        if (!baseIds.includes(obj.incrementId)) baseIds.push(obj.incrementId);
        this._applySelectionFromIds(baseIds, true);

        canvas.requestRenderAll();
        this._emitAnnotationSelectionChanged(baseIds, true, fromCanvas);
    }


    /**
     * Deselect an annotation by incrementId.
     * Handles single and multi-selection.
     * @param {fabric.Object|string|number} object object or incrementId of the annotation to deselect
     * @param {boolean} [fromCanvas=false]
     * @returns {void}
     */
    deselectAnnotation(object, fromCanvas=false) {
        const canvas = this.canvas;
        const obj = typeof object === 'object' ? object : this.findObjectOnCanvasByIncrementId(object);
        if (!obj) return;

        let baseIds = this.__snapshotIsModifierToggle ? (this.__selectionSnapshot?.map(x => x.incrementId) || []) : this.getSelectionSnapshot();
        baseIds = baseIds.filter(x => x !== obj.incrementId);
        this._applySelectionFromIds(baseIds);

        canvas.requestRenderAll();
        this._emitAnnotationSelectionChanged(baseIds, false, fromCanvas);
    }

    /********************* PRIVATE **********************/

    getSelectionSnapshot() {
        const active = this.canvas.getActiveObject();
        if (!active) return [];
        if (active.type === 'activeSelection') return active._objects.map(o => o.incrementId);
        return [active.incrementId];
    }

    clearSelectionSnapshot(keepCached=false) {
        if (!keepCached) this.__selectionSnapshot = null;
        this.__snapshotIsModifierToggle = false;
    }

    _applySelectionFromIds(ids) {
        const canvas = this.canvas;
        if (!ids || ids.length === 0) {
            canvas.discardActiveObject();
            canvas.requestRenderAll();
            return;
        }
        const objs = ids
            .map(id => this.findObjectOnCanvasByIncrementId(Number(id)))
            .filter(Boolean);

        if (objs.length === 1) {
            const obj = objs[0];
            canvas.setActiveObject(obj);
            this.__selectionSnapshot = [obj];
        } else {
            // active is single object, convert to ActiveSelection
            const sel = new fabric.ActiveSelection([], { canvas });
            // Build selection incrementally to keep child positions intact
            for (let o of objs) {
                sel.addWithUpdate(o);
            }
            sel.hasBorders = false;
            sel.hasControls = false;
            canvas.setActiveObject(sel);
            this.__selectionSnapshot = sel._objects;
        }

        canvas.requestRenderAll();
    }

    /**
     * Emit annotation selection change
     */
    _emitAnnotationSelectionChanged(annotationIds, isSelected, fromCanvas) {
        const ids = Array.isArray(annotationIds)
            ? annotationIds.map(id => String(id))
            : (annotationIds !== undefined && annotationIds !== null ? String(annotationIds) : annotationIds);

        // todo selection event collision
        this.raiseEvent('annotation-selection-changed', {
            ids: ids,
            isSelected: isSelected,
            fromCanvas: fromCanvas
        });
    }

    /**
     * Clear all annotation selection
     */
    clearAnnotationSelection(fromCanvas=false) {
        this.__selectionSnapshot = [];
        const selected = this.getSelectedAnnotationIds();
        if (!selected.length) return;

        this.canvas.discardActiveObject();
        this.canvas.requestRenderAll();
        // this.__oldSelection = null;

        this._emitAnnotationSelectionChanged(selected, false, fromCanvas);
    }

    /**
     * Check if an annotation object is currently selected.
     * Works with single and multi-selection.
     * @param {fabric.Object} object annotation object to test
     * @param {fabric.Object|fabric.ActiveSelection|fabric.Object[]} [reference] optionally, perform the test against custom selection reference
     * @returns {boolean} true if selected
     */
    isAnnotationSelected(object, reference = null) {
        if (!object) return false;

        if (Array.isArray(reference)) {
            return reference.find(x => x.incrementId === object.incrementId);
        }

        const active = reference || this.canvas.getActiveObject();
        if (!active) return false;
        if (active.type === 'activeSelection') {
            return !!(active._objects && active._objects.find(x => x.incrementId === object.incrementId));
        }
        return active.incrementId === object.incrementId;
    }

    /**
     * Delete all selected annotations and layers
     * @param {boolean} withWarning show warning if nothing is selected
     * @returns {void}
     */
    deleteSelection(withWarning=true) {
        const layerIds = [...(this.getSelectedLayerIds?.() || [])];
        const selectedAnnObjs = (this.getSelectedAnnotations?.() || []);

        if (layerIds.length === 0 && selectedAnnObjs.length === 0) {
            if (withWarning) {
                Dialogs.show("Please select annotations or layers you would like to delete", 3000, Dialogs.MSG_INFO);
            }
            return;
        }

        const layerIdSet = new Set(layerIds.map(String));
        const annToDelete = selectedAnnObjs.filter(obj => !layerIdSet.has(String(obj.layerID)));

        const layersData = layerIds
            .map(id => this._serializeLayer?.(String(id)))
            .filter(Boolean);

        for (const obj of annToDelete) {
            if (obj.layerID) {
                const layer = this.getLayer(obj.layerID);
                obj._position = layer ? layer.getAnnotationIndex(obj) : undefined;
            } else {
                obj._position = this.module.historyManager.getBoardIndex('annotation', obj.incrementId);
            }
        }

        const combined = [
            ...layersData.map(ld => ({ type: "layer", data: ld, pos: ld._position })),
            ...annToDelete.map(a => ({ type: "annotation", data: a, pos: a._position }))
        ].sort((a, b) => (a.pos ?? 0) - (b.pos ?? 0));

        this.module.history.push(
            () => {
                for (const item of [...combined].reverse()) {
                    if (item.type === "annotation") {
                        this._deleteAnnotation?.(item.data, true);
                    } else {
                        this._deleteLayer?.(String(item.data.id));
                    }
                }
                this.clearLayerSelection?.(true);
                this.clearAnnotationSelection?.(true);
            },
            () => {
                for (const item of combined) {
                    if (item.type === "annotation") {
                        this._addAnnotation?.(item.data, true);
                    } else {
                        this._createLayer?.(item.data);
                    }
                }
            }
        );
    }

    /**
     * Find all objects that intersects with target bbox
     * @param bbox
     * @param {function} transformer transform object somehow, if falsey value returned the object is skipped
     * @returns {[fabric.Object]}
     */
    findIntersectingObjectsByBBox(bbox, transformer=x => x) {
        // Cache all targets where their bounding box contains point.
        const objects = this.canvas._objects;
        let targets = [], i = objects.length;
        while (i--) {
            const object = objects[i];
            const coords = object.aCoords;
            if (OSDAnnotations.PolygonUtilities.intersectAABB(bbox, {
                    x: coords.tl.x,
                    y: coords.tl.y,
                    width: coords.br.x - coords.tl.x,
                    height: coords.br.y - coords.tl.y
                }
            )) {
                const result = transformer(object);
                result && targets.push(result);
            }
        }
        return targets;
    }

    /**
     * Clear fabric selection (of any kind)
     */
    clearSelection() {
        this.canvas.selection = false;
    }

    /**
     * Delete currently active object
     * @param {boolean} [withWarning=true] whether user should get warning in case action did not do anything
     */
    removeActiveObject(withWarning=true) {
        let activeObject = this.canvas.getActiveObject();
        if (!activeObject) {
            if (withWarning) {
                Dialogs.show("Please select the annotation you would like to delete", 3000, Dialogs.MSG_INFO);
            }
            return;
        }

        if (activeObject.type === 'activeSelection') {
            activeObject.getObjects().forEach(obj => {
                this.deleteObject(obj);
            });
            this.canvas.requestRenderAll();
        } else {
            this.deleteObject(activeObject);
        }
    }

    /**
     * Delete all annotations
     */
    deleteAllAnnotations() {
        for (let facId in this.module.objectFactories) {
            if (!this.module.objectFactories.hasOwnProperty(facId)) continue;
            this.module.objectFactories[facId].finishDirect();
        }

        let objects = this.canvas.getObjects();
        if (!objects || objects.length === 0) return;

        let objectsLength = objects.length;
        for (let i = 0; i < objectsLength; i++) {
            this.deleteObject(objects[objectsLength - i - 1]);
        }
    }

    /**
     * Update single object visuals
     * @param {fabric.Object} object
     * @return {boolean} true on update success
     */
    updateSingleAnnotationVisuals(object) {
        if (object.isHighlight) return false;

        let preset = this.module.presets.get(object.presetID);
        if (preset) {
            const factory = this.module.getAnnotationObjectFactory(object.factoryID);
            const visuals = {...this.module.presets.commonAnnotationVisuals};
            factory.updateRendering(object, preset, visuals, visuals);

            const isSelected = this.isAnnotationSelected(object);
            if (isSelected) factory?.applySelectionStyle?.(object, this);
            return true;
        }
        // todo consider adding such preset
        console.warn("[updateSingleAnnotationVisuals] annotation does not have according preset!", object);
        return false;
    }

    /**
     * Update all object visuals
     * @type function
     */
    updateAnnotationVisuals = UTILITIES.makeThrottled(() => {
        // fixme iterate all
        this.canvas.getObjects().forEach(o => this.updateSingleAnnotationVisuals(o));
        this.canvas.requestRenderAll();
        this.raiseEvent('visual-property-changed', {visuals: this.module.presets.commonAnnotationVisuals});
    }, 180);

    _setListeners() {
        const _this = this;

        // todo this event is called too often when clicking, the update should be preformed once to reflect the correct state - e.g. prevent by flag, or add deferred execution
        this.addHandler('annotation-selection-changed', (payload) => {
            const ids = Array.isArray(payload.ids) ? payload.ids : [payload.ids];

            ids.forEach(id => {
                const annotation = _this.findObjectOnCanvasByIncrementId(Number(id));
                if (annotation) _this.updateSingleAnnotationVisuals(annotation);
            });
        });

        this.viewer.addHandler('screenshot', e => {
            e.context2D.drawImage(this.canvas.getElement(), 0, 0);
        });

        /**************************************************************************************************
         Click Handlers
         Input must be always the event invoked by the user input and point in the image coordinates
         (absolute pixel position in the scan)
         **************************************************************************************************/

        let screenToPixelCoords = function (x, y) {
            //cannot use this.viewer.scalebar.imagePixelSizeOnScreen() because of canvas margins
            return this.viewer.scalebar.getReferencedTiledImage().windowToImageCoordinates(new OpenSeadragon.Point(x, y));
        }.bind(this);

        //prevents event bubling if the up event was handled by annotations
        function handleRightClickUp(event, fabricEvent) {
            if (_this.module.disabledInteraction) return;
            if (!_this.module.cursor.isDown) {
                //todo in auto mode, this event is fired twice!! fix
                if (_this.module.cursor.mouseTime === Infinity) {
                    _this.module.raiseEvent('nonprimary-release-not-handled', {
                        originalEvent: event,
                        pressTime: _this.module.cursor.abortedTime
                    });
                }
                _this.module.cursor.mouseTime = -1;
                return;
            }

            let factory = _this.module.presets.right ? _this.module.presets.right.objectFactory : undefined;
            let point = screenToPixelCoords(event.x, event.y);
            if (_this.module.mode.handleClickUp(event, point, false, factory)) {
                event.preventDefault();
            } else {
                //todo better system by e.g. unifying the events, allowing cancellability and providing only interface to modes
                _this.module.raiseEvent('nonprimary-release-not-handled', {
                    originalEvent: event,
                    pressTime: _this.module.cursor.mouseTime === Infinity ? _this.module.cursor.abortedTime : _this.module.cursor.mouseTime
                });
            }

            _this.module.cursor.isDown = false;
        }

        function handleRightClickDown(event, fabricEvent) {
            if (_this.module.cursor.isDown || _this.module.disabledInteraction) return;

            _this.module.cursor.mouseTime = Date.now();

            let factory = _this.module.presets.right ? _this.module.presets.right.objectFactory : undefined;
            let point = screenToPixelCoords(event.x, event.y);
            _this.module.mode.handleClickDown(event, point, false, factory);
            // set after handleClickDown -> viewerLocked will be set to false by default after we set isDown to true
            _this.module.cursor.isDown = true;
        }

        function handleLeftClickUp(event, fabricEvent) {
            if (_this.module.disabledInteraction) return;

            if (!_this.module.cursor.isDown) {
                //todo in auto mode, this event is fired twice!! fix
                if (_this.module.cursor.mouseTime === Infinity) {
                    _this.module.raiseEvent('canvas-release', {
                        originalEvent: event,
                        pressTime: _this.module.cursor.abortedTime
                    });
                }
                _this.module.cursor.mouseTime = -1;
                return;
            }

            let factory = _this.module.presets.left ? _this.module.presets.left.objectFactory : undefined;
            let point = screenToPixelCoords(event.x, event.y);
            if (_this.module.mode.handleClickUp(event, point, true, factory)) {
                event.preventDefault();
            } else /*if (!_this.isModeAuto())*/ {
                // left click up handles selection for all modes if mode did not handle the event
                if (fabricEvent.target) {
                    _this._objectClicked(fabricEvent, point);
                }

                //todo better system by e.g. unifying the events, allowing cancellability and providing only interface to modes
                _this.module.raiseEvent('canvas-release', {
                    originalEvent: event,
                    pressTime: _this.module.cursor.mouseTime === Infinity ? _this.module.cursor.abortedTime : _this.module.cursor.mouseTime
                });
            }

            _this.module.cursor.isDown = false;
        }

        function handleLeftClickDown(event, fabricEvent) {
            if (_this.module.cursor.isDown || _this.module.disabledInteraction) return;

            _this.module.cursor.mouseTime = Date.now();

            let factory = _this.module.presets.left ? _this.module.presets.left.objectFactory : undefined;
            if (!factory) {
                // try to recover
                const presets = _this.module.presets.getExistingIds();
                if (presets.length > 0) {
                    factory = presets[0];
                    _this.module.setPreset(factory, true);
                }
            }
            let point = screenToPixelCoords(event.x, event.y);
            _this.module.mode.handleClickDown(event, point, true, factory);
            // set after handleClickDown -> viewerLocked will be set to false by default after we set isDown to true
            _this.module.cursor.isDown = true;
        }

        /****** E V E N T  L I S T E N E R S: FABRIC (called when not navigating) **********/

        // annotationCanvas.addEventListener("mousedown", function (event) {
        this.canvas.on('mouse:down', function(e) {
            if (_this.module.disabledInteraction || (!_this.module.mode.supportsZoomAnimation() && _this.module.mode.isZooming)) return;
            const event = e.e;
            if (event.which === 1) handleLeftClickDown(event, e);
            else if (event.which === 3) handleRightClickDown(event, e);
        });

        // annotationCanvas.addEventListener('mouseup', function (event) {
        this.canvas.on('mouse:up', function(e) {
            if (_this.module.disabledInteraction) return;
            const event = e.e;
            if (event.which === 1) handleLeftClickUp(event, e);
            else if (event.which === 3) handleRightClickUp(event, e);
        });

        // let annotationCanvas = this.canvas.upperCanvasEl;
        // annotationCanvas.addEventListener("mousedown", function (event) {
        // 	if (_this.module.disabledInteraction || (!_this.module.mode.supportsZoomAnimation() && _this.module.mode.isZooming)) return;
        //
        // 	if (event.which === 1) handleLeftClickDown(event);
        // 	else if (event.which === 3) handleRightClickDown(event);
        // });
        //
        // annotationCanvas.addEventListener('mouseup', function (event) {
        // 	if (_this.module.disabledInteraction) return;
        //
        // 	if (event.which === 1) handleLeftClickUp(event);
        // 	else if (event.which === 3) handleRightClickUp(event);
        // });

        this.canvas.on('mouse:move', function (o) {
            if (_this.module.disabledInteraction) return;
            if (_this.module.cursor.isDown) {
                _this.module.mode.handleMouseMove(o.e, screenToPixelCoords(o.e.x, o.e.y));
            } else {
                _this.module.mode.handleMouseHover(o.e, screenToPixelCoords(o.e.x, o.e.y));
            }
        });

        this.canvas.on('mouse:wheel', function (o) {
            if (_this.module.disabledInteraction) return;

            if (_this.module.isModeAuto() || _this.module._wasModeFiredByKey || o.e.shiftKey) {
                _this.module.mode.scroll(o.e, o.e.deltaY);
            } else {
                if (!_this.module.mode.supportsZoomAnimation() && _this.module.cursor.isDown) handleLeftClickUp(o.e);

                _this._fireMouseWheelNavigation(o.e);
                _this.module.mode.scrollZooming(o.e, o.e.deltaY);
            }
        });

        const handleDeselectionFromCanvas = (e) => {
            const ids = (e?.deselected || []).map(obj => obj.incrementId);
            if (ids.length) _this._emitAnnotationSelectionChanged(ids, false, true);
            this.clearSelectionSnapshot(true);
        };
        this.canvas.on('selection:updated', handleDeselectionFromCanvas);
        this.canvas.on('selection:cleared', handleDeselectionFromCanvas);

        /****** E V E N T  L I S T E N E R S: OSD  (called when navigating) **********/

        // todo: somehow get rid of this dirty call
        this.viewer.addHandler("animation-start", function() {
            Object.values(_this.module.Modes).forEach(mode => mode.onZoomStart());
        });
        // todo: somehow get rid of this dirty call
        this.viewer.addHandler("animation-finish", function() {
            Object.values(_this.module.Modes).forEach(mode => mode.onZoomEnd());
        });

        // OSD Blocks event when such event is taken care of (e.g. navigation) -> relay it to fabric
        this.viewer.addHandler("canvas-press", function (e) {
            _this.canvas._onMouseDown(e.originalEvent);
        });
        this.viewer.addHandler("canvas-release", function (e) {
            _this.canvas._onMouseUp(e.originalEvent);
        });
        this.viewer.addHandler("canvas-nonprimary-press", function (e) {
            _this.canvas._onMouseDown(e.originalEvent);
        });
        this.viewer.addHandler("canvas-nonprimary-release", function (e) {
            _this.canvas._onMouseUp(e.originalEvent);
        });

        // Wheel while viewer runs not enabled because this already performs zoom.
        // this.viewer.addHandler("canvas-scroll", function (e) { ... });
    }

    // Copied out of OpenSeadragon private code scope to allow manual scroll navigation
    _fireMouseWheelNavigation(event) {
        // Simulate a 'wheel' event
        const tracker = this.viewer.innerTracker;
        const simulatedEvent = {
            target:	 event.target || event.srcElement,
            type:	   "wheel",
            shiftKey:   event.shiftKey || false,
            clientX:	event.clientX,
            clientY:	event.clientY,
            pageX:	  event.pageX ? event.pageX : event.clientX,
            pageY:	  event.pageY ? event.pageY : event.clientY,
            deltaMode:  event.type === "MozMousePixelScroll" ? 0 : 1, // 0=pixel, 1=line, 2=page
            deltaX:	 0,
            deltaZ:	 0
        };

        // Calculate deltaY
        if ( OpenSeadragon.MouseTracker.wheelEventName === "mousewheel" ) {
            simulatedEvent.deltaY = -event.wheelDelta / OpenSeadragon.DEFAULT_SETTINGS.pixelsPerWheelLine;
        } else {
            simulatedEvent.deltaY = event.deltaY;
        }
        const originalEvent = event;
        event = simulatedEvent;

        var nDelta, eventInfo, eventArgs = null;
        nDelta = event.deltaY < 0 ? 1 : -1;
        eventInfo = {
            originalEvent: event,
            eventType: 'wheel',
            pointerType: 'mouse',
            isEmulated: event !== originalEvent,
            eventSource: tracker,
            eventPhase: event ? ((typeof event.eventPhase !== 'undefined') ? event.eventPhase : 0) : 0,
            defaultPrevented: OpenSeadragon.eventIsCanceled( event ),
            shouldCapture: false,
            shouldReleaseCapture: false,
            userData: tracker.userData,
            isStoppable: true,
            isCancelable: true,
            preventDefault: false,
            preventGesture: !tracker.hasScrollHandler,
            stopPropagation: false,
        };

        if ( tracker.preProcessEventHandler ) {
            tracker.preProcessEventHandler( eventInfo );
        }

        if ( tracker.scrollHandler && !eventInfo.preventGesture && !eventInfo.defaultPrevented ) {
            eventArgs = {
                eventSource:		  tracker,
                pointerType:		  'mouse',
                position:			 OpenSeadragon.getMousePosition( event ).minus( OpenSeadragon.getElementOffset( tracker.element )),
                scroll:			   nDelta,
                shift:				event.shiftKey,
                isTouchEvent:		 false,
                originalEvent:		originalEvent,
                preventDefault:	   eventInfo.preventDefault || eventInfo.defaultPrevented,
                userData:			 tracker.userData
            };
            tracker.scrollHandler( eventArgs );
        }
        if ( eventInfo.stopPropagation ) {
            OpenSeadragon.stopEvent( originalEvent );
        }
        if (( eventArgs && eventArgs.preventDefault ) || ( eventInfo.preventDefault && !eventInfo.defaultPrevented ) ) {
            OpenSeadragon.cancelEvent( originalEvent );
        }
    }

    _objectClicked(event, point) {

        try {
            let clickedObject = event.target;
            const originalEvent = event.e;
            // non-user event, selection fired by the system (e.g. annotation added to canvas)
            if (!originalEvent || !clickedObject) return;

            // const isOnActive = !!(active && active.containsPoint && active.containsPoint(pointer));

            if (clickedObject.type === 'activeSelection') {
                // todo simona moved code here to compute only when needed, select one to use

                const pointer = this.canvas.getPointer(event);

                // const point = new OpenSeadragon.Point(originalEvent.x, originalEvent.y);
                // const pointer = this.viewer.scalebar.getReferencedTiledImage().imageToWindowCoordinates(point);

                // todo simona removed pointer creation here, re-using the created one above, either we use image-coords-level pointer or window, don't create a third one, if you prefer creation of
                //  fabric pointer, create it above
                for (const obj of clickedObject._objects) {
                    let currObj = {
                        left: obj.left + clickedObject.left + (clickedObject.width / 2),
                        top: obj.top + clickedObject.top + (clickedObject.height / 2),
                        width: obj.width,
                        height: obj.height
                    }

                    if (
                        pointer.x >= currObj.left &&
                        pointer.x <= currObj.left + currObj.width &&
                        pointer.y >= currObj.top &&
                        pointer.y <= currObj.top + currObj.height
                    ) {
                        // todo simona this needs to do fine selection upon AAB hit similar to what brush tool does, but RN it is point VS polygon - simpler

                        // select only if not already selected
                        if (clickedObject !== obj) {
                            clickedObject = obj;
                        }
                        break;
                    }
                }
            }

            if (clickedObject.type === 'activeSelection') {
                // this happens if the active selection is 'above' the clicked object, which is not part of the selection,
                // but hidden underneath -> find the object!
                clickedObject = this.canvas.findNextObjectUnderMouse(event.pointer, clickedObject);
            }

            if (!clickedObject) {
                this.clearAnnotationSelection(true);
                return;
            }

            if (this.module.historyManager.isOngoingEditOf(clickedObject)) {
                if (this.module.isMouseOSDInteractive()) {
                    // todo this should be hidden in factory api
                    clickedObject.set({
                        hasControls: false,
                        lockMovementX: true,
                        lockMovementY: true
                    });
                }
                return;
            }

            if (originalEvent.ctrlKey || originalEvent.metaKey || originalEvent.shiftKey) {
                this.__snapshotIsModifierToggle = true;
                //
                // // check old selection
                // const isSelected = this.isAnnotationSelected(clickedObject, this.__oldSelection);
                // // If the mode does not allow, skip
                // if (isSelected && this.module.mode.objectDeselected(event, object)) {
                //	 this.deselectAnnotation(clickedObject, true);
                // } else if (!isSelected && this.module.mode.objectSelected(event, object)) {
                //	 this.selectAnnotation(clickedObject, true);
                // }

                const ref = this.__selectionSnapshot || [];
                const isSelected = this.isAnnotationSelected(clickedObject, ref);
                if (isSelected && this.module.mode.objectDeselected(event, clickedObject)) {
                    this.deselectAnnotation(clickedObject, true);
                } else if (!isSelected && this.module.mode.objectSelected(event, clickedObject)) {
                    this.selectAnnotation(clickedObject, true);
                }
                return;
            }

            // If the mode does not allow selection, skip
            if (!this.module.mode.objectSelected(event, clickedObject)) {
                return;
            }

            this.__snapshotIsModifierToggle = false;
            // todo: this calls the event with updates TWICE -> it would be better to have a single event with all the updates
            this.clearAnnotationSelection(true);
            this.selectAnnotation(clickedObject, true);
        } catch (e) {
            console.error(e);
        }
    }

    /**
     * Removes the current highlight of annotation, if any
     */
    removeHighlight() {
        this.setHighlight(null);
    }

    /**
     * Highlights selected annotation by adding highlight object as
     * helper annotation
     * @param {fabric.Object} selectedObject selected annotation to highlight
     */
    async highlightAnnotation(selectedObject) {
        this.removeHighlight();

        let factory = this.module.getAnnotationObjectFactory(selectedObject.factoryID);
        if (!factory) return;

        const highlight = await factory.selected(selectedObject);
        if (!highlight) return;

        this.setHighlight(highlight);
    }


    /**
     * Sets the highlight object, removing any existing one first
     * @param {fabric.Object} highlightObject the object to be set as highlight
     */
    setHighlight(highlightObject) {
        if (this._currentHighlight) {
            this.deleteHelperAnnotation(this._currentHighlight);
            this._currentHighlight = null;
        }

        if (highlightObject) {
            this._currentHighlight = highlightObject;
            this.addHelperAnnotation(highlightObject);
        }
    }

    /**
     * Retrieves the currently active highlight object, if any
     * @returns {fabric.Object|null} the highlight object or null if none
     */
    getHighlight() {
        return this._currentHighlight;
    }

    _loadObjects(input, clear, inheritSession = false) {
        //from loadFromJSON implementation in fabricJS
        const _this = this.canvas, self = this;

        // If we get already fabric.js objects, avoid passing them to enlivenObjects
        const fabricObjects = [];
        const nonFabricObjects = [];
        for (let obj of input.objects) {
            if (obj instanceof fabric.Object) {
                fabricObjects.push(obj);
            } else {
                const factory = this.module.getAnnotationObjectFactory(obj.factoryID);
                factory.initializeBeforeImport(obj);
                nonFabricObjects.push(obj);
            }
        }

        const zoom = this.canvas.getZoom();
        const graphicZoom = this.canvas.computeGraphicZoom(zoom);

        return fabric.util.enlivenObjects(nonFabricObjects, objects => {
            if (clear) {
                this.canvas.clear();
                this.module.historyManager.clearBoard();
                this._layers = {};
                this._layer = undefined;
                this.clearAnnotationSelection();
                this.clearLayerSelection();
                this.unsetActiveLayer();
            }
            let insertion = 0;

            function initObject(obj) {
                if (inheritSession && !obj.sessionID) {
                    obj.sessionID = self.module.session;
                }
                self.checkLayer(obj);

                self.module.checkAnnotation(obj, zoom, graphicZoom);
                _this.insertAt(obj, insertion++);
            }

            for (let obj of objects) {
                initObject(obj);
            }

            // Process also enlivenObjects - avoided items
            for (let obj of fabricObjects) {
                initObject(obj);
            }
            self.historyManager.assignIDs(_this.getObjects());
        });
    }

    _debugActiveObjectBinder() {
        this.canvas.__eventListeners = {};
        const get = this.canvas.getActiveObject.bind(this.canvas);
        let self = this;
        this.canvas.getActiveObject = function() {
            let e = get();
            console.log("GET", e ? e.selectable : "", e, self.canvas._activeObject);
            return e;
        };
        const set = this.canvas.setActiveObject.bind(this.canvas);
        this.canvas.setActiveObject = function(e, t) {
            console.log("SET", e, t);
            return set(e, t);
        };
        const disc = this.canvas._discardActiveObject.bind(this.canvas);
        this.canvas._discardActiveObject = function(e, t) {
            console.log("DISCARD", e, self.canvas.__eventListeners);
            return disc(e, t);
        };
    }
}
requireViewerSingletonPresence(OSDAnnotations.FabricWrapper);